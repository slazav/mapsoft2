#!/usr/bin/perl
use warnings;
use strict;

# Print list of modules which are needed for building of
# a given module or a program.
#
# Usage:
#   get_deps <lib directory> <modules or source files> ...
#

my $mod_dir = shift @ARGV || '.';
my @targets = @ARGV;

$#targets>=0 or die "Usage: get_deps <lib directory> <target> ...\n";

######################################################################
# read Makefile, extract list of sources (cpp, h)
sub read_make ($) {
  my $fname = shift;
  my %info;
  open F, $fname or die "can't read $fname file: $!";
  while (my $line = <F>){
    next unless $line =~ /^\s*([A-Za-z0-9_]+)\s*:?=\s*(.*)/;
    my $key = $1;
    $line = $2;
    # join lines with \ at the end, remove extra spaces
    $line .= <F> while $line =~ /\\$/;
    $line =~ s/\\\n//g;
    $line =~ s/\s+/ /g;
    $info{$key} = $line;
  }
  close F;
  return %info;
}

# read sources, extract dependencies (only #include "<name>/<file>")
sub get_hdeps ($$) {
  my $dir = shift;
  my $files = shift;
  my (%hdeps, %mdeps);
  foreach my $f (@{$files}) {
    unless(open F, "$dir/$f"){
      warn "can't open $dir/$f: $!";
      next;
    }
    while (my $l=<F>) {
      next unless $l=~/^#/;
      if ($l=~m|^#include\s+"([^"/]+)/([^"/]+)"|) {
        $hdeps{"$1/$2"} = 1;
        $mdeps{"$1"} = 1;
      }
    }
    close F;
  }
  return %mdeps;
}

# recurcively go through all modules, collect their dependencies
sub add_mod_dep {
  my $mods = shift;
  my $mod = shift;
  my $skip = shift || 0;
  my %info = read_make "$mod_dir/$mod/Makefile";
  my @files = split /\s+/, ($info{MOD_SOURCES}||'')." ".($info{MOD_HEADERS}||'');
  my %mdeps = get_hdeps("$mod_dir/$mod", \@files);
  $mods->{$mod} = [keys %mdeps] unless $skip;
  add_mod_dep($mods, $_) foreach (keys %mdeps);
}

# build an ordered dependencie list
sub optimize_deps {
  my $mods = shift;
  my @ret;
  while (keys %{$mods} >0) {
    # find module with no deps
    my $m0 = '';
    foreach my $m (keys %{$mods}) {
      next unless $#{$mods->{$m}}==-1;
      $m0 = $m;
      last;
    }
    $m0 ne '' or die "Dependency calculation faild: no independent modules";
    # add it to build list, remove from dep list
    push @ret, $m0;
    delete $mods->{$m0};
    foreach my $m (keys %{$mods}) {
      my @ii = grep { ${$mods->{$m}}[$_] eq $m0 } 0..$#{$mods->{$m}};
      splice(@{$mods->{$m}}, $_, 1) foreach (@ii);
    }
  }
  return @ret;
}

my %mods;
foreach my $target (@targets) {
  if (-d "$mod_dir/$target") {
    add_mod_dep(\%mods, $target, 1);
  }
  elsif (-f $target) {
    my %mdeps = get_hdeps(".", [$target]);
    add_mod_dep(\%mods, $_) foreach (keys %mdeps);
  }
  else {
    warn "No file or directory: $target\n";
  }
}

my @list = optimize_deps(\%mods);
print "$_\n" foreach (@list);

